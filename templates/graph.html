<!DOCTYPE html>
<meta charset="utf-8">
<meta http-equiv="pragma" content="no-cache">
<meta http-equiv="expires" content="-1">
<html>

<head>
    <link rel="stylesheet" type="text/css" href="{{ url_for('static', filename='stylesheets/graph.css') }}">
</head>

<body>
    <script src="{{ url_for('static', filename='lib/d3.v3.min.js') }}"></script>

    <div id="graph"></div>

    <form action="graph">
        <fieldset>
            <legend>Graph Search:</legend>
            Topic:
            <input type="text" name="seed" value="programming">&emsp;&emsp; Breadth limit:
            <input type="text" name="breadth" value="3">&emsp;&emsp; Depth limit:
            <input type="text" name="depth" value="4">&emsp;&emsp; NSFW:
            <input type="checkbox" name="nsfw" value="true">&emsp;&emsp;
            <input type="submit" value="Submit">
        </fieldset>
    </form>

    <script>
        d3.json("{{filename}}", function(data) {
            var width = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
            var height = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
            // Add whitespace
            width -= 20;
            height -= 100;

            var force = d3.layout.force()
                .size([width, height])
                .linkDistance(80)
                .charge(-300)
                .gravity(0.1)
                .on("tick", tick);

            var svg = d3.select("#graph").append("svg")
                .attr("width", width)
                .attr("height", height)
                .attr('viewBox', '0 0 ' + Math.min(width, height) + ' ' + Math.min(width, height))
                .attr('preserveAspectRatio', 'xMinYMin')
                .attr("transform", "translate(" + Math.min(width, height) / 2 + "," + Math.min(width, height) / 2 + ")")
                .style("border", "1px solid black")
                .call(d3.behavior.zoom().on("zoom", function() {
                    svg.attr("transform", "translate(" + d3.event.translate + ")" + " scale(" + d3.event.scale + ")")
                }))
                .append("g");

            var view = svg.append("view")
                .attr("id", "view")
                .attr("viewBox", "500 500 1000 1000");

            var path = svg.append("g").selectAll("path"),
                circle = svg.append("g").selectAll("circle"),
                hypertext = svg.append("g").selectAll("text");

            var marker = svg.append("defs").append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 15)
                .attr("refY", -1.5)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5");

            var nodes = data.nodes;
            var links = data.links;

            update(links);

            function update(links) {
                // Compute the distinct nodes from the links.
                links.forEach(function(link) {
                    link.source = nodes[link.source];
                    link.target = nodes[link.target];
                });

                force.nodes(nodes)
                    .links(links)
                    .start();

                // -------------------------------

                // Compute the data join. This returns the update selection.
                path = path.data(force.links());

                // Remove any outgoing/old paths.
                path.exit().remove();

                // Compute new attributes for entering and updating paths.
                path.enter().append("path")
                    .attr("class", "link")
                    .style("stroke", function(d) {
                        return d3.rgb(5 * d.value, 200 + d.value, 127 - 2 * d.value);
                    })
                    .attr("marker-end", "url(#arrow)");

                // -------------------------------

                // Compute the data join. This returns the update selection.
                circle = circle.data(force.nodes());

                // Add any incoming circles.
                circle.enter().append("circle");

                // Remove any outgoing/old circles.
                circle.exit().remove();

                // Compute new attributes for entering and updating circles.
                circle.attr("r", 15)
                    .attr("is", function(d) {
                        return "node-" + d.name
                    })
                    .call(force.drag);


                // Compute the data join. This returns the update selection.
                hypertext = hypertext.data(force.nodes());

                // Add any incoming texts.
                hypertext.enter().append("text")
                    .append("a")
                    //.attr("xlink:show", "new")
                    .attr("target", "_blank");

                // Remove any outgoing/old texts.
                hypertext.exit().remove();

                // Compute new attributes for entering and updating texts.
                hypertext.attr("x", 0)
                    .attr("y", ".31em")
                    .select("a")
                    .attr("xlink:href", function(d) {
                        return "http://reddit.com/r/" + d.name;
                    })
                    .text(function(d) {
                        return d.name;
                    });
            }

            // Use elliptical arc path segments to doubly-encode directionality.
            function tick() {
                path.attr("d", linkArc);
                circle.attr("transform", transform);
                hypertext.attr("transform", transform);
            }

            function linkArc(d) {
                var dx = d.target.x - d.source.x,
                    dy = d.target.y - d.source.y,
                    dr = Math.sqrt(dx * dx + dy * dy);
                return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + d.target.x + "," + d.target.y;
            }

            function transform(d) {
                return "translate(" + d.x + "," + d.y + ")";
            }

        });
    </script>

</body>

</html>
